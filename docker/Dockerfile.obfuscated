# syntax=docker/dockerfile:1
# ConfigFlow 混淆版本 Dockerfile（简化版，使用 PyArmor 免费功能）

# ==============================================================================
# Stage 1: Builder - 构建 Go Agent 二进制文件
# ==============================================================================
FROM golang:1.21-alpine AS go-builder

WORKDIR /build

ENV GOPROXY=https://goproxy.cn,direct

# 使用 bind mount 避免 Go 源码保留在镜像层中
RUN --mount=type=bind,source=backend/agents/go-agent,target=/src \
    --mount=type=cache,target=/go/pkg/mod \
    echo "=== 复制 Go 模块文件并下载依赖 ===" && \
    cp /src/go.mod /src/go.sum ./ && \
    go mod download && \
    echo "=== 复制 Go 源码并构建二进制文件 ===" && \
    cp -r /src/* ./ && \
    mkdir -p /dist && \
    echo "Building Go Agent binaries..." && \
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o /dist/configflow-agent-linux-amd64 . && \
    CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o /dist/configflow-agent-linux-arm64 . && \
    CGO_ENABLED=0 GOOS=linux GOARCH=arm GOARM=7 go build -ldflags="-s -w" -o /dist/configflow-agent-linux-armv7 . && \
    echo "=== 清理 Go 源码 ===" && \
    rm -rf /build/* && \
    echo "✓ Go 源码已清理，只保留二进制文件" && \
    ls -lh /dist/

# ==============================================================================
# Stage 2: 构建前端
# ==============================================================================
FROM node:18-alpine AS frontend-builder

WORKDIR /app/frontend

# 使用 bind mount 避免前端源码保留在镜像层中
RUN --mount=type=bind,source=frontend,target=/src \
    --mount=type=cache,target=/root/.npm \
    echo "=== 复制 package 文件并安装依赖 ===" && \
    cp /src/package*.json ./ && \
    npm ci && \
    echo "=== 复制前端源码并构建 ===" && \
    cp -r /src/* ./ && \
    npm run build && \
    echo "=== 清理前端源码，只保留构建产物 ===" && \
    find . -mindepth 1 ! -path './dist*' -delete && \
    echo "✓ 前端源码已清理，只保留 dist 目录" && \
    ls -la

# ==============================================================================
# Stage 3: 构建混淆的 Python 后端二进制
# ==============================================================================
FROM python:3.11-slim AS python-builder

WORKDIR /build

# 安装系统构建依赖（PyInstaller 需要 binutils）
RUN apt-get update && \
    apt-get install -y --no-install-recommends binutils && \
    rm -rf /var/lib/apt/lists/*

# 安装 Python 构建依赖
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install --upgrade pip && \
    pip install pyarmor pyinstaller

# 使用 RUN --mount 在同一层中复制、混淆并删除原始代码
# 这样原始源码不会保留在任何 Docker 层中
RUN --mount=type=bind,source=backend,target=/src/backend \
    --mount=type=bind,source=main.py,target=/src/main.py \
    echo "=== 复制并混淆代码（不保留原始源码到镜像层） ===" && \
    cp -r /src/backend ./backend && \
    cp /src/main.py ./main.py && \
    echo "=== 确保 backend 是 Python 包 ===" && \
    if [ ! -f "backend/__init__.py" ]; then \
        echo "# Backend package" > backend/__init__.py; \
    fi && \
    echo "=== 备份资源文件 ===" && \
    cp backend/config_template.json /tmp/config_template.json && \
    echo "=== 显示 PyArmor 版本 ===" && \
    pyarmor --version && \
    echo "=== 开始混淆 Python 代码 ===" && \
    pyarmor gen --recursive --output obfuscated_temp backend/ 2>&1 || { \
        echo "PyArmor gen 失败，尝试使用旧版命令..." && \
        pyarmor obfuscate --recursive --output obfuscated_temp backend/__init__.py 2>&1 || { \
            echo "混淆失败，跳过混淆步骤，直接使用原始代码" && \
            mkdir -p obfuscated_temp && \
            cp -r backend obfuscated_temp/backend; \
        }; \
    } && \
    echo "✓ 代码处理完成" && \
    echo "=== 检查输出目录 ===" && \
    ls -la obfuscated_temp/ && \
    echo "=== 移动 PyArmor 运行时文件（如果存在） ===" && \
    (mv obfuscated_temp/pyarmor_runtime_* ./ 2>/dev/null || echo "无运行时文件需要移动") && \
    echo "=== 删除原始源码并替换为混淆版本 ===" && \
    rm -rf backend/ main.py && \
    mv obfuscated_temp/backend backend/ && \
    rm -rf obfuscated_temp && \
    echo "=== 恢复资源文件 ===" && \
    cp /tmp/config_template.json backend/config_template.json && \
    echo "✓ 原始源码已被混淆版本替换，不保留在镜像层" && \
    ls -la backend/

# 复制前端构建产物
COPY --from=frontend-builder /app/frontend/dist ./frontend/dist/

# 创建混淆版本的启动文件
RUN cat > main_obfuscated.py << 'EOF'
#!/usr/bin/env python3
import sys
import os

# 处理 PyInstaller 打包环境
if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
    # PyInstaller 环境：添加 _MEIPASS 到路径
    sys.path.insert(0, sys._MEIPASS)
else:
    # 开发环境：添加当前目录到路径
    sys.path.insert(0, os.path.dirname(__file__))

# 导入混淆后的 app 模块（包名保持为 backend）
from backend.app import app

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001)
EOF

# 创建 PyInstaller spec 文件（单文件模式）
RUN cat > config_flow.spec << 'EOF'
# -*- mode: python ; coding: utf-8 -*-
import os
import sys
import glob

block_cipher = None

# 收集数据文件
datas = []
binaries = []
hiddenimports = []

# 添加前端静态文件
if os.path.exists('frontend/dist'):
    datas.append(('frontend/dist', 'static'))

# 添加整个混淆后的 backend 目录作为数据文件
# 注意：config_template.json 会随 backend 目录一起打包
if os.path.exists('backend'):
    # 收集所有混淆后的文件（包括 .py 和其他资源文件）
    for root, dirs, files in os.walk('backend'):
        for file in files:
            src_path = os.path.join(root, file)
            # 计算相对路径，保持目录结构
            rel_dir = os.path.dirname(src_path)
            datas.append((src_path, rel_dir))

# 添加 PyArmor 运行时文件
pyarmor_runtime = glob.glob('pyarmor_runtime_*')
for runtime_dir in pyarmor_runtime:
    if os.path.isdir(runtime_dir):
        for root, dirs, files in os.walk(runtime_dir):
            for file in files:
                src_path = os.path.join(root, file)
                rel_dir = os.path.dirname(src_path)
                datas.append((src_path, rel_dir))

# 添加必要的隐藏导入
hiddenimports += [
    'flask', 'flask_cors', 'yaml', 'requests', 'urllib3', 'jwt',
    'webdav3', 'webdav3.client', 'webdav3.connection', 'webdav3.exceptions',
    'cryptography',
    'cryptography.fernet',
    'cryptography.hazmat.primitives',
    'cryptography.hazmat.primitives.ciphers',
    'cryptography.hazmat.primitives.ciphers.aead',
    'cryptography.hazmat.primitives.asymmetric',
    'cryptography.hazmat.primitives.kdf',
    'cryptography.hazmat.primitives.kdf.pbkdf2',
    'cryptography.hazmat.backends',
    'cryptography.hazmat.backends.openssl',
    'logging.handlers',
    'logging.config',
    # backend 模块
    'backend',
    'backend.agents',
    'backend.agents.manager',
    'backend.agents.config_generator',
    'backend.agents.install_script',
    'backend.agents.go_install_script',
    'backend.agents.metrics_history',
    'backend.agents.version',
    'backend.common',
    'backend.common.config',
    'backend.common.agent_manager',
    'backend.common.auth',
    'backend.common.utils',
    'backend.common.resource',
    'backend.converters',
    'backend.converters.mihomo',
    'backend.converters.mosdns',
    'backend.converters.surge',
    'backend.routes',
    'backend.utils',
    'backend.utils.logger',
    'backend.utils.subscription_parser',
    'backend.utils.subscription_cache',
    'backend.utils.rule_matcher',
    'backend.utils.rule_utils',
    'backend.models',
    'backend.models.config',
]

a = Analysis(
    ['main_obfuscated.py'],
    pathex=['.'],
    binaries=binaries,
    datas=datas,
    hiddenimports=hiddenimports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

# 单文件模式：所有内容打包到一个可执行文件中
exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='config_flow',
    debug=False,
    bootloader_ignore_signals=False,
    strip=True,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=True,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)
EOF

# 安装 Python 运行时依赖
COPY backend/requirements.txt ./
RUN --mount=type=cache,target=/root/.cache/pip pip install -r requirements.txt

# 使用 PyInstaller 打包
RUN echo "=== 开始打包二进制文件 ===" && \
    pyinstaller --clean --noconfirm config_flow.spec && \
    echo "✓ 打包完成" && \
    ls -lh dist/

# 验证单文件打包成功
RUN echo "=== 验证单文件打包 ===" && \
    if [ -f "dist/config_flow" ]; then \
        echo "✓ 单文件打包成功"; \
        ls -lh dist/config_flow; \
    else \
        echo "✗ 打包失败: 找不到 dist/config_flow"; \
        ls -la dist/; \
        exit 1; \
    fi

# 创建部署目录并复制单个可执行文件
RUN mkdir -p /app_dist && \
    cp dist/config_flow /app_dist/config_flow && \
    chmod +x /app_dist/config_flow

# ==============================================================================
# Stage 4: 最小化运行容器
# ==============================================================================
FROM ubuntu:24.04

WORKDIR /app

# 安装运行时依赖
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    apt-get update && \
    apt-get install -y --no-install-recommends \
    nginx \
    supervisor \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/* && \
    groupadd -r nginx || true && \
    useradd -r -g nginx -s /sbin/nologin -d /nonexistent nginx || true && \
    mkdir -p /data /var/log/supervisor /var/cache/nginx /var/log/nginx /usr/share/nginx/html && \
    chown -R nginx:nginx /var/cache/nginx /var/log/nginx /usr/share/nginx/html && \
    chmod -R 755 /usr/share/nginx/html && \
    chmod -R 777 /data

# 复制单个二进制文件到 /app（单文件模式，无 _internal 目录）
COPY --from=python-builder /app_dist/config_flow /app/config_flow

# 复制 Go Agent 二进制文件
RUN mkdir -p /opt/configflow/static/agents
COPY --from=go-builder /dist/ /opt/configflow/static/agents/

# 复制前端静态文件
COPY --from=frontend-builder /app/frontend/dist /usr/share/nginx/html

# 复制 Nginx 配置
COPY docker/nginx.conf /etc/nginx/nginx.conf

# 设置权限
RUN chown -R nginx:nginx /usr/share/nginx/html && \
    chmod -R 755 /usr/share/nginx/html

# 创建 Supervisor 配置
RUN echo '[supervisord]\n\
nodaemon=true\n\
logfile=/var/log/supervisor/supervisord.log\n\
pidfile=/var/run/supervisord.pid\n\
\n\
[program:nginx]\n\
command=/usr/sbin/nginx -g "daemon off;"\n\
autostart=true\n\
autorestart=true\n\
stdout_logfile=/dev/stdout\n\
stdout_logfile_maxbytes=0\n\
stderr_logfile=/dev/stderr\n\
stderr_logfile_maxbytes=0\n\
\n\
[program:config_flow]\n\
command=/app/config_flow\n\
directory=/app\n\
autostart=true\n\
autorestart=true\n\
stdout_logfile=/dev/stdout\n\
stdout_logfile_maxbytes=0\n\
stderr_logfile=/dev/stderr\n\
stderr_logfile_maxbytes=0\n\
environment=DATA_DIR=/data\n\
' > /etc/supervisor/conf.d/supervisord.conf

# 设置环境变量
ENV DATA_DIR=/data \
    TZ=Asia/Shanghai

# 确保二进制文件可执行
RUN chmod +x /app/config_flow

# 最终验证
RUN echo "=== 运行容器验证 ===" && \
    echo "单文件可执行文件:" && \
    ls -lh /app/config_flow && \
    echo "" && \
    echo "/app 目录内容:" && \
    ls -la /app/ && \
    echo "" && \
    echo "✓ PyInstaller 单文件模式打包完成" && \
    echo "✓ 所有代码已通过 PyArmor 混淆并打包到单个二进制文件" && \
    echo "✓ 可执行文件在 /app/config_flow" && \
    echo "✓ 无 _internal 目录（单文件模式）" && \
    echo "✓ 运行时会自动解压到临时目录" && \
    if [ -d "/app/_internal" ]; then \
        echo "✗ 警告: _internal 目录存在（不应该出现在单文件模式）"; \
        exit 1; \
    else \
        echo "✓ 确认: 无 _internal 目录"; \
    fi

# 暴露端口
EXPOSE 80

# 启动服务
CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/conf.d/supervisord.conf"]
